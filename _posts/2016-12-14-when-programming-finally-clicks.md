---
layout: post
title: When Programming Finally Clicks
---
The moment I pressed start and the colored lights flashed to the beeps, I was filled with joy. In the months that passed since I had  began learning how to code, this little game was the first project I approached with a sound plan that I could execute from start to finish. That was a very big deal to me. Before, I would spin my wheels and not know where to begin. I would scratch out plans A-Z and search for any sort of outside help to figure out what I could do to solve my problems. Learning how to code involves more than learning the language. First, you have to learn a different way to think.


Many early lessons involve real world scenarios to help students visualize the task. One problem I did involved counting change from a register. There are two ways to think about this problem. The first way, is the natural way. This is the human way to solve the problem. The cashier counts the total cost of the items, then subtracts the total from the cash paid by the customer. Then the cashier looks in the drawer for the appropriate change. It doesn’t have to be the best change, it just has to work. The second way is how a machine would have to solve it. The machine can do things perfectly, but it can’t improvise and it’s best if what it has to do repeats. So to solve it, after the total is subtracted from the cash, I created a set of if/else decisions for the computer to decide which bills and which coins should be distributed. If the change was higher than the bill value, subtract the bill value from the change. If there was still change, repeat the process. If the change was higher than the bill value, move on to the next lowest drawer, etc. On the surface, this is an easy problem, but to a beginner, breaking down something that comes natural is a strange experience.


As the problems become more abstract, this way of thinking can be frustrating, if you don’t know how to break problems down for machines. Fortunately, after putting in some long hours and hair pulling sessions, I got used to thinking in a different way. When I finally came upon the project to create a memory game like Simon, I looked at what the game needed to function and I wrote down everything I needed to build like a random pattern generator, a reset button, a buzzer for incorrect input, and a way to freeze user input, so they can’t interrupt essential game processes. It didn’t work perfectly straight from the blueprint, but much of my time was spent refining and solving how it worked rather than being frustrated with the basic logic and structure of the game. I felt good when I was planning, but I truly realized I hit the point when everything clicked when I hit that button and saw the game buzz to life. It’s a feeling I hope every new development student can feel, because there were many times when I thought I was getting myself into something that would forever be beyond my understanding. Something told me to keep going despite the struggle. It wasn’t natural talent that got me to that point. It was persistent practice. That’s when I realized that even the most difficult problems could be understood eventually with grit and determination.
